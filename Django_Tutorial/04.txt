1. Write a minimal form

    polls/templates/polls/detail.html 을 열고,
    <form> 요소를 포함시켜보자.

    <form action="{% url "polls:vote" question.id %}" method="post">
    {% csrf_token %}
        <fieldset>
            <legend>
                <h1>{{ question.question_text }}</h1>
            </legend>
            {% if error_message %}
            <p>
                <strong>{{ error_message }}</strong>
            </p>
            {% endif %}
            {% for choice in question.choice_set.all %}
            <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
            <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label>
            <br>
            {% endfor %}
        </fieldset>
    <input type="submit" value="Vote">
    </form>

    - csrf_token
        csrf 공격에 대한 방어를 위한 토큰
        POST 요청 시 csrf_token 에 대해 유효성을 검사하여 방어한다.
    
    - forloop.counter
        몇 번째 for-loop 인지, 1부터 시작한다.
    

    polls/views.py 를 열고, vote 함수를 제대로 구현해보자.

    from django.http import HttpResponse, HttpResponseRedirect
    from django.shortcuts import get_object_or_404, render
    from django.urls import reverse

    from .models import Choice, Question

    def vote(request, question_id):
        question = get_object_or_404(Question, pk=question_id)
        try:
            selected_choice = question.choice_set.get(pk=request.POST['choice'])    # detail.html 에서 POST 형식으로 보낸 choice.id 로 어느것을 골랐는지 특정한다.
        except (KeyError, Choice.DoesNotExist):                                     # 아무것도 고르지 않거나, 에러 발생시 예외 처리
            # Redisplay the question voting form.
            return render(request, 'polls/detail.html', {
                'question': question,
                'error_message': "You didn't select a choice.",
            })
        else:
            selected_choice.votes += 1      # 투표 수를 증가시키고,
            selected_choice.save()          # 저장한다.
            return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))

    - HttpResponseRedirect
        뒤로가기 버튼을 눌렀을 경우 데이터가 두 번 POST 되는 것을 막는다.

    - reverse
        URL 패턴의 변수 부분을 조합해서 해당 뷰를 가리킨다.
        위에서는 /polls/question.id/results 라는 문자열을 반환한다.
        추적한다는 의미에서 reverse 인듯 ?
    

    polls/views.py 를 열고, results 뷰를 수정하자.

    from django.shortcuts import get_object_or_404, render


    def results(request, question_id):
        question = get_object_or_404(Question, pk=question_id)
        return render(request, 'polls/results.html', {'question': question})

    polls/templates/polls/results.html 을 만들고,

    <h1>{{ question.question_text }}</h1>

    <ul>
    {% for choice in question.choice_set.all %}
        <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>    # pluralize 복수형으로 만들어준다. vote => votes
    {% endfor %}
    </ul>

    <a href="{% url 'polls:detail' question.id %}">Vote again?</a>


    이렇게 만든 vote 뷰에는 작은 문제가 있다.
    만약 두 명의 사용자가 정확하게 같은 시각에 투표를 하려고 시도할 경우, 값을 제대로 저장하지 못할 수 있다.
    이를 '경쟁 상태'라고 부른다.

    F() expressions 를 읽어보면,
    F 표현식을 사용하면, 단순히 Python 구문을 실행하는 것이 아니라,
    데이터베이스에 대한 작업을 설명하는 SQL 구문이라 기술되어 있으며,
    데이터베이스 필드를 증가시키거나 하는 명령을 데이터베이스에 지시하는 것이다.

    Avoiding race conditions using F() 를 읽어보면,
    F 표현식을 사용하여 '경쟁 조건'을 피할 수 있다는 점이다.
    다음과 같이 사용한다.

    from django.db.models import F

    abc.aaa = F("aaa") + 1
    abc.save()