1. 테스트 자동화 소개

    - 테스트 자동화란?

        테스트는 다양한 수준에서 작동한다.

        일부 테스트는 작은 세부 사항에 적용될 수 있다. (특정 모델 메서드는 예상대로 값을 반환하는가?)
        또 다른 테스트는 소프트웨어의 전반적인 작동을 검사한다. (사이트에서 사용자 입력 시퀀스가 원하는 결과를 생성하는가?)

        이전에 shell 을 사용하여 메소드의 동작을 검사하거나, 어플리케이션을 실행하고 어떻게 작동하는지 확인하기 위해 데이터를 입력해서 테스트했던 것과 크게 다르지 않다.
    
     - 테스트를 만들어야 하는 이유

        테스트를 통해 시간을 절약 할 수 있다.

        특정 시점까지는 '제대로 작동하는지 확인'하는 것이 테스트로서 충분하다.
        더 정교한 어플리케이션에서는 구성 요소간에 수십개의 복잡한 상호 작용이 있을 수 있다.
        이러한 구성 요소를 변경했을 때, 프로그램의 동작에 예기치 않은 결과가 발생할 수 있다.
        문제를 찾아내기 위해 일일히 데이터를 집어 넣어 보는 것은 가능하겠지만, 시간이 굉장히 오래 걸릴 수 있다.

        이 수동 테스트 작업을 자동화하면 시간을 많이 아낄 수 있다.

    - 테스트는 문제르 그저 식별하는 것이 아니라 예방한다.

        테스트가 없다면, 어플리케이션의 목적 또는 의도된 동작이 다소 불투명할 수 있다.
        심지어 자신의 코드가 정확히 무엇을 하고 있는지 알아내려고 노력해야 될 수도 있다.

        테스트는 이 불투명함을 바꾼다. 내부에서 코드를 밝혀내고, 어떤 것이 잘못 될 때,
        그것이 잘못되었다는 것을 깨닫지 못했다고 할지라도, 잘못된 부분에 빛을 집중시킨다.

    - 테스트가 코드를 더 매력적으로 만든다.

        "Code without tests is broken by design." - Jacob Kaplan-Moss (Django's orginal developers)
        
        테스트 작성을 시작해야하는 또 다른 이유는 다른 개발자들이 당신의 소프트웨어를 사용하는 것을 진지하게 고려하기 전에 테스트 코드를 보고 싶어한다.
    
    - 테스트는 팀이 함께 일하는 것을 돕는다.

        복잡한 어플리케이션의 경우, 팀별로 유지 관리가 된다.
        테스트는 동료가 실수로 코드를 손상시키지 않는다는 것을 보증한다. (당신이 코드를 망가트리는 것도)


2. 기초 테스팅 전략

    일부 프로그래머들은 'test-driven development'라는 원칙을 따른다.
    그들은 실제로 코드를 작성하기 전에 테스트를 작성한다.
    이것은 직관적이지 않은 것처럼 보일 수 있지만 사실 대부부의 사람들이 흔히 하는 일과 비슷하다.
    문제를 설명한 다음 이를 해결하기 위한 코드를 생성한다.
    test-driven development 는 Python 테스트 케이스에서 문제를 공식화한다.

    테스트 작성이 너무 늦어서는 안된다.

    수천 줄의 코드를 작성해 놓았다면, 어느 것을 테스트해야 할 지 고르는 것도 쉽지 않다.
    그럴 때는 새로운 기능을 넣거나 버그를 수정하는 등, 코드를 변경할 일이 있을 때, 당신의 첫 테스트를 작성하는 것이 유익할 것이다.


3. 첫 번째 테스트 작성하기

    - 버그 식별하기
        Question.was_published_recently() 메소드는 Question 의 pub_date 가 미래로 설정되어 있을 때도 True 를 반환한다.
        이것은 옳지 못하다.
        shell 을 사용해 미래의 날짜로 메소드를 실행해 버그를 확인해보자.

        $ python manage.py shell

        >>> import datetime
        >>> from django.utils import timezone
        >>> from polls.models import Question

        새 Question 객체를 만들고, pub_date 를 미래로 설정한 뒤 확인해보자.

        >>> future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))   
        >>> future_question.was_published_recently()
        True

    - 버그를 노출하는 테스트 만들기
        문제를 테스트하기 위해 shell 에서 방금 수행한 작업을 테스트 자동화해보자.

        polls/tests.py 를 열고 다음과 같이 작성해보자.

        from django.test import TestCase
        from django.utils import timezone
        from .models import Question
        import datetime


        class QuestionModelTests(TestCase):

            def test_was_published_recently_with_future_question(self):
                time = timezone.now() + datetime.timedelta(day=30)
                future_question = Question(pub_date=time)
                self.assertIs(future_question.was_published_recently(), False)
    
    - 테스트 실행

        $ python manage.py test polls

        Creating test database for alias 'default'...                   # (3)
        System check identified no issues (0 silenced).
        F
        ======================================================================
        FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests)     # (4, 5)
        ----------------------------------------------------------------------
        Traceback (most recent call last):
        File "C:\Users\pc\Desktop\Python\Python_Django\mysite\polls\tests.py", line 12, in test_was_published_recently_with_future_question
            self.assertIs(future_question.was_published_recently(), False)
        AssertionError: True is not False                                                           # (6)

        ----------------------------------------------------------------------
        Ran 1 test in 0.001s

        FAILED (failures=1)
        Destroying test database for alias 'default'...

        1. manage.py test polls 는 polls 어플리케이션에서 테스트를 찾는다.
        2. django.test.TestCase 클래스의 서브 클래스를 찾는다.
        3. 테스트 목적으로 특별한 데이터베으스를 만든다.
        4. 테스트 메소드 - 이름이 test 로 시작하는 것들을 찾는다.
        5. test_was_published_recently_with_future_question 에서 pub_date 필드가 30일 미래인 Question 인스턴스를 생성한다.
        6. assertIs() 메소드를 사용하여, False 가 반환되길 기대했으나 True 로 반환된 것을 확인했다.
    
    - 버그 수정
        Question.was_published_recently() 는 pub_date 가 미래에 있다면 False 를 반환해야 한다.
        models.py 에서 날짜가 과거에 있을 때에만 True 를 반환하도록 메소드를 수정해보자.

        polls/models.py 를 열고 다음과 같이 수정하자.

        def was_published_recently(self):
            now = timezone.now()
            return now - datetime.timedelta(days=1) <= self.pub_date <= now
        
        다시 테스트를 실행해보자.

        Creating test database for alias 'default'...
        System check identified no issues (0 silenced).
        .
        ----------------------------------------------------------------------
        Ran 1 test in 0.001s

        OK
        Destroying test database for alias 'default'...

        코드에서 버그를 수정하고 테스트를 통과했다.